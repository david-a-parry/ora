import sys
import logging
from collections import namedtuple, defaultdict
from ora.ensembl_rest_queries import EnsemblRestQueries
from ora.id_parser import parse_id
from ora.uniprot_lookups import get_uniprot_features, feat_fields
from ora.uniprot_lookups import logger as unipro_logger
from ora.alignments import write_alignments
from ora.alignments import get_align_pos, align_pos_to_amino_acid

ParalogLookup = namedtuple("ParalogLookup", "gene protein position")
ensg2symbol = dict()
uniprot_lookups = set()
ens_rest = EnsemblRestQueries()
logger = logging.getLogger("ORA REST")
logger.setLevel(logging.INFO)


def get_gene_details(x, species='human'):
    id_info = parse_id(x)
    logger.info("Interpretting input as {}".format(id_info['identifier_type']))
    if id_info['is_ensembl_id']:
        if id_info['is_transcript']:
            data = ens_rest.gene_from_enst(x)
        elif id_info['is_protein']:
            data = ens_rest.gene_from_ensp(x)
        else:
            return x  # is ensembl gene id
        if data:
            return data['id']
    else:
        data = ens_rest.get_via_xref(x, species, 'gene')
        if data:
            if len(data) > 1:
                logger.warning("Multiple genes identified for input '{}'"
                               .format(x))
                logger.debug("Ids are: " + ", ".join(x['id'] for x in data))
                logger.warning("Using ID from first of multiple lookups ({})"
                               .format(data[0]['id']))
            return data[0]['id']
    sys.exit("FAILED: Could not retrieve Ensembl gene ID for input '{}'"
             .format(x))


def check_paralog_lookups(original_ensg, output_results, results):
    '''
        If we have results with a paralog of our original query gene as
        the query gene we should output an alignment of our original
        query gene and the paralog if we aren't already doing so. This
        returns results for our original query gene and these paralogs
        if not already in our output_results.
    '''
    # All pairwise comparisons in our output list
    pair_comps = set((r['query_gene'], r['homolog_gene']) for r in
                     output_results)
    # Pairwise comparisons where the query gene is paralogous to our query
    para_comps = set((r['query_gene'], r['homolog_gene']) for r in
                     output_results if r['query_gene'] != original_ensg)
    extra = list()
    for pair in para_comps:
        if (original_ensg, pair[0]) not in pair_comps:
            extra.extend(r for r in results if r['query_gene'] == original_ensg
                         and r['homolog_gene'] == pair[0])
    return extra


def parse_homology_data(homs, positions, protein_id=None, skip_paralogs=False,
                        output_all_orthologs=False):
    '''
        From a list of homologies (generated from Ensembl REST look-ups
        or ora.local_lookups) return results detailing homologies and any
        Uniprot features overlapping given positions.

        Args:
             homs: list of homology results as generated by
                   EnsemblRestQueries.get_homologies method.

             positions:
                   list of protein positions in query protein to check.

             protein_id:
                   restrict lookups to source proteins matching this
                   protein ID

            skip_paralogs:
                   do not perform lookups for paralogs

            output_all_orthologs:
                   set 'should_output' to True for all ortholog results
                   even if no overlapping Uniprot features are identified.

    '''
    paralogs = defaultdict(list)
    results = []
    logger.info("Got {:,} homologs".format(len(homs)))
    for pos in positions:
        for i in range(len(homs)):
            s_id = homs[i]['source']['id']
            t_id = homs[i]['target']['id']
            s_protein = homs[i]['source']['protein_id']
            t_protein = homs[i]['target']['protein_id']
            s_seq = homs[i]['source']['align_seq']
            t_seq = homs[i]['target']['align_seq']
            p = get_align_pos(s_seq, pos)
            if (s_protein, pos) not in uniprot_lookups:
                ufeats = get_uniprot_features(s_protein, pos, pos)
                if ufeats:
                    for f in ufeats:
                        result = dict(
                            query_gene=s_id,
                            query_protein=s_protein,
                            query_pos=pos,
                            query_aa=s_seq[p],
                            homolog_gene=s_id,
                            homolog_protein=s_protein,
                            orthology_type="self",
                            species=homs[i]['source']['species'],
                            percent_id=100,
                            percent_pos=100,
                            homolog_pos=pos,
                            homolog_aa=s_seq[p],
                            query_species=homs[i]['source']['species'],
                            features=f,
                            should_output=True)
                        results.append(result)
                uniprot_lookups.add((s_protein, pos))
            if protein_id is not None and s_protein != protein_id:
                logger.info("Skipping paralog lookup for protein {}\n".format(
                    protein_id))
                return results, paralogs
            hom_type = homs[i]['type']
            if skip_paralogs and 'paralog' in hom_type:
                continue
            o, aa = align_pos_to_amino_acid(t_seq, p) if p > 0 else (-1, '-')
            if 'paralog' in hom_type and o > 0:
                paralogs[t_id].append(ParalogLookup(t_id, t_protein, o))
            if o > 0 and (t_protein, o) not in uniprot_lookups:
                result_template = dict(
                                    query_gene=s_id,
                                    query_protein=s_protein,
                                    query_pos=pos,
                                    query_aa=s_seq[p],
                                    homolog_gene=t_id,
                                    homolog_protein=t_protein,
                                    orthology_type=hom_type,
                                    species=homs[i]['target']['species'],
                                    percent_id=homs[i]['target']['perc_id'],
                                    percent_pos=homs[i]['target']['perc_pos'],
                                    homolog_pos=o,
                                    query_seq=s_seq,
                                    homolog_seq=t_seq,
                                    query_species=homs[i]['source']['species'],
                                    homolog_aa=aa,
                                    should_output=False)
                ufeats = get_uniprot_features(t_protein, o, o)
                if ufeats:
                    for f in ufeats:
                        result = result_template.copy()
                        result['features'] = f
                        result['should_output'] = True
                        results.append(result)
                else:
                    result = result_template.copy()
                    result['features'] = dict((x, '-') for x in feat_fields)
                    result['should_output'] = output_all_orthologs
                    results.append(result)
                uniprot_lookups.add((t_protein, o))
    if not skip_paralogs:
        logger.info("Got {} paralog sequences".format(len(paralogs)))
    return results, paralogs


def lookup_symbols(ensgs):
    logger.info("Looking up gene symbols for {:,} IDs".format(len(ensgs)))
    datastring = '{"ids": [' + ", ".join('"' + x + '"' for x in ensgs) + ' ] }'
    data = ens_rest.get_endpoint("/lookup/id", data=datastring)
    if data:
        return dict((k, v.get('display_name', '-')) for k, v in data.items())
    logger.warning("No gene symbols found by POST lookup")
    return dict()


def remote_lookups(gene, pos, paralog_lookups=False, line_length=60,
                   timeout=10.0, max_retries=2, all_homologs=False,
                   output_alignments=None, quiet=False, debug=False,
                   silent=False):
    if silent:
        logger.setLevel(logging.ERROR)
    elif quiet:
        logger.setLevel(logging.WARN)
    elif debug:
        logger.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        '[%(asctime)s] %(name)s - %(levelname)s - %(message)s')
    ch = logging.StreamHandler()
    ch.setLevel(logger.level)
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    unipro_logger.setLevel(logger.level)
    ens_rest.logger.setLevel(logger.level)
    for handler in ens_rest.logger.handlers + unipro_logger.handlers:
        handler.setLevel(logger.level)
    ens_rest.timeout = timeout
    ens_rest.max_retries = max_retries
    ensg = get_gene_details(gene)
    if ensg != gene:
        logger.info("Got Ensembl Gene ID '{}'".format(ensg))
    data = ens_rest.get_homologies(ensg)
    if data is None:
        sys.exit("ERROR: Could not find ensembl gene '{}'".format(ensg))
    if output_alignments:
        alignment_fh = open(output_alignments, 'wt')
    header_fields = '''Query_Symbol Query_Gene Query_Protein Query_Pos
                       Query_AA Homolog_Symbol Homolog_Gene Homolog_Protein
                       Orthology_Type Species Percent_ID Percent_Pos
                       Homolog_Pos Homolog_AA'''.split()
    print("\t".join(header_fields + feat_fields))
    results, paralogs = parse_homology_data(data['data'][0]['homologies'],
                                            pos,
                                            output_all_orthologs=all_homologs)
    if paralog_lookups:
        n_paralogs = len(paralogs.keys())
        i = 0
        for gene_id, paralog_list in paralogs.items():
            i += 1
            logger.info("Parsing paralog {:,} of {:,}".format(i, n_paralogs))
            try:
                pdata = ens_rest.get_homologies(gene_id)
            except Exception as e:
                logger.warning("Error looking up paralog {}: {}".format(
                    gene_id, e))
                continue
            pro2pos = defaultdict(list)
            for para in paralog_list:
                pro2pos[para.protein].append(para.position)
            for protein, positions in pro2pos.items():
                p_results, _ = parse_homology_data(
                    pdata['data'][0]['homologies'],
                    positions,
                    protein_id=protein,
                    skip_paralogs=True)
                results.extend(p_results)
    output_results = [r for r in results if r['should_output']]
    if not output_results:
        logger.info("No results for {} position {}".format(gene, pos))
        sys.exit()
    symbol_lookups = set(x['homolog_gene'] for x in output_results)
    symbol_lookups.update(x['query_gene'] for x in output_results)
    ensg2symbol = lookup_symbols(symbol_lookups)
    if output_alignments:
        extra_alignments = check_paralog_lookups(ensg, output_results, results)
        write_alignments(output_results + extra_alignments, alignment_fh,
                         ensg2symbol,
                         linelen=line_length)
        alignment_fh.close()
    for res in output_results:
        res['query_symbol'] = ensg2symbol.get(res['query_gene'], '-')
        res['homolog_symbol'] = ensg2symbol.get(res['homolog_gene'], '-')
        line = [str(res[x.lower()]) for x in header_fields] + \
               [str(res['features'][x]) for x in feat_fields]
        print("\t".join(line))
